/*
** LDF for ADSP-BF533.
** 
** There are a number of configuration options that can be specified
** either by compiler flags, or by linker flags directly. The options are:
** 
*/

ARCHITECTURE(ADSP-BF533)

#ifndef __NO_STD_LIB
SEARCH_DIR( $ADI_DSP/Blackfin/lib )
#endif

/* Moving to primIO means that we must always include the FileIO support,
** so that printf() will work.
*/

#ifndef USE_FILEIO	/* { */
#define USE_FILEIO 1
#endif	/* } */

#define MEMINIT
#ifdef __WORKAROUNDS_ENABLED	/* { */
#define LIBSMALL libsmall532y.dlb,
#else
#define LIBSMALL libsmall532.dlb,
#endif	/* } */

#ifdef M3_RESERVED	/* { */
#ifdef __WORKAROUNDS_ENABLED	/* { */
#define LIBM3 libm3res532y.dlb
#define LIBDSP libdspm3res532y.dlb
#define SFTFLT libsftflt532y.dlb
#else
#define LIBM3 libm3res532.dlb
#define LIBDSP libdspm3res532.dlb
#define SFTFLT libsftflt532.dlb
#endif	/* } */
#else
#ifdef __WORKAROUNDS_ENABLED	/* { */
#define LIBM3 libm3free532y.dlb
#define LIBDSP libdsp532y.dlb
#define SFTFLT libsftflt532y.dlb
#else
#define LIBM3 libm3free532.dlb
#define LIBDSP libdsp532.dlb
#define SFTFLT libsftflt532.dlb
#endif	/* } */
#endif	/* } */

#ifdef IEEEFP	/* { */
#define FPLIBS SFTFLT, LIBDSP
#else
#define FPLIBS LIBDSP, SFTFLT
#endif	/* } */


#ifdef __WORKAROUNDS_ENABLED	/* { */
#define LIBS LIBSMALL MEMINIT libc532y.dlb, LIBM3, libevent532y.dlb, libio532y.dlb, FPLIBS, libetsi532.dlb
#else
#define LIBS LIBSMALL MEMINIT libc532.dlb, LIBM3, libevent532.dlb, libio532.dlb, FPLIBS, libetsi532.dlb
#endif	/* } */
#if defined(USE_FILEIO) || defined(USE_PROFGUIDE)
#ifdef __WORKAROUNDS_ENABLED	/* { */
$LIBRARIES = LIBS, librt_fileio532y.dlb;
#else
$LIBRARIES = LIBS, librt_fileio532.dlb;
#endif	/* } */
#else
#ifdef __WORKAROUNDS_ENABLED	/* { */
$LIBRARIES = LIBS, librt532y.dlb;
#else
$LIBRARIES = LIBS, librt532.dlb;
#endif	/* } */
#endif	/* } */

// Libraries from the command line are included in COMMAND_LINE_OBJECTS.


$OBJECTS = $COMMAND_LINE_OBJECTS;

MEMORY
{
#if 0
MEM_CORE_MMRS  {	/* Core memory-mapped registers - 2MB */
	TYPE(RAM) WIDTH(8)
	START(0xFFE00000) END(0xFFFFFFFF)
}
#endif
MEM_SYS_MMRS  {	/* System memory-mapped registers - 2MB */
	TYPE(RAM) WIDTH(8)
	START(0xFFC00000) END(0xFFDFFFFF)
}
MEM_L1_SCRATCH  {
	TYPE(RAM) WIDTH(8)
	START(0xFFB00000) END(0xFFB00FFF)
}
/* Instruction SRAM, 82K, some useable as cache */
MEM_L1_CODE_CACHE {	/* L1 Instruction SRAM/Cache - 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFFA10000) END(0xFFA13FFF)
}
MEM_L1_CODE {	/* L1 Instruction - 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFFA00000) END(0xFFA0FFFF)
}
/* Data Bank B - 32K, half usable as cache. */
/* Split into sections for program layout. */
/* Data - normal data, 16K */
MEM_L1_DATA_B_CACHE	{	/* L1 Data B SRAM/Cache - 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFF904000) END(0xFF907FFF)
}
/* Data2 - const data, 8K */
MEM_L1_DATA_B       {	/* L1 Data B SRAM - half of 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFF902000) END(0xFF903FFF)
}
/* Stack - 8K */
MEM_L1_DATA_B_STACK       {	/* L1 Data B SRAM cont. - other half of 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFF900000) END(0xFF901FFF)
}
/* Data Bank A - 32K, half usable as cache. */
/* Split into sections for program layout. */
/* Data - normal data, 16K. */
MEM_L1_DATA_A_CACHE        {	/* L1 Data A SRAM/Cache - 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFF804000) END(0xFF807FFF)
}
MEM_L1_DATA_A        {	/* L1 Data A SRAM - 16K */
	TYPE(RAM) WIDTH(8)
	START(0xFF800000) END(0xFF803FFF)
}
MEM_ASYNC3     {	/* Async Bank 3 - 1MB */
	TYPE(RAM) WIDTH(8)
	START(0x20300000) END(0x203FFFFF)
}
MEM_ASYNC2     {	/* Async Bank 2 - 1MB */
	TYPE(RAM) WIDTH(8)
	START(0x20200000) END(0x202FFFFF)
}
MEM_ASYNC1     {	/* Async Bank 1 - 1MB */
	TYPE(RAM) WIDTH(8)
	START(0x20100000) END(0x201FFFFF)
}
MEM_ASYNC0     {	/* Async Bank 0 - 1MB */
	TYPE(RAM) WIDTH(8)
	START(0x20000000) END(0x200FFFFF)
}

/* Claim some of SDRAM Bank 0 for heap */
/* since it needs a separate section */

MEM_SDRAM0     {	/* SDRAM Bank 0 - 16MB-128M */
	TYPE(RAM) WIDTH(8)
	START(0x00004000) END(0x07FFFFFF)
}
MEM_SDRAM0_HEAP     {	/* Claim some for ext heap - 16K */
	TYPE(RAM) WIDTH(8)
	START(0x00000004) END(0x00003FFF)
}
}

PROCESSOR P0
{
    OUTPUT( $COMMAND_LINE_OUTPUT_FILE )

    SECTIONS
    {
        program_ram
        {
            INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_code) $LIBRARIES(L1_code))
            INPUT_SECTIONS( $OBJECTS(cplb_code) $LIBRARIES(cplb_code))
            INPUT_SECTIONS( $OBJECTS(cplb) $LIBRARIES(cplb))
            INPUT_SECTIONS( $OBJECTS(program) $LIBRARIES(program))
        } >MEM_L1_CODE

        l1_code
        {
#ifdef USE_CACHE /* { */
		___l1_code_cache = 1;
#else
		___l1_code_cache = 0;
            INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_code) $LIBRARIES(L1_code))
            INPUT_SECTIONS( $OBJECTS(cplb_code) $LIBRARIES(cplb_code))
            INPUT_SECTIONS( $OBJECTS(cplb) $LIBRARIES(cplb))
            INPUT_SECTIONS( $OBJECTS(program) $LIBRARIES(program))
#endif /* USE_CACHE } */
        } >MEM_L1_CODE_CACHE


        constdata
        {
	    INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_data_a) $LIBRARIES(L1_data_a))
            INPUT_SECTIONS( $OBJECTS(cplb_data) $LIBRARIES(cplb_data))
            INPUT_SECTIONS($OBJECTS(data1) $LIBRARIES(data1))
	    INPUT_SECTIONS($OBJECTS(voldata) $LIBRARIES(voldata))
	    INPUT_SECTIONS($OBJECTS(constdata) $LIBRARIES(constdata))
        } >MEM_L1_DATA_A


        data
        {
	    INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_data_b) $LIBRARIES(L1_data_b))
            INPUT_SECTIONS( $OBJECTS(cplb_data) $LIBRARIES(cplb_data))
            INPUT_SECTIONS($OBJECTS(data1) $LIBRARIES(data1))
	    INPUT_SECTIONS($OBJECTS(voldata) $LIBRARIES(voldata))
	    INPUT_SECTIONS($OBJECTS(constdata) $LIBRARIES(constdata))
        } >MEM_L1_DATA_B


        l1_data_a
        {
#ifdef USE_CACHE /* { */
		___l1_data_cache_a = 1;
#else
		___l1_data_cache_a = 0;
	    INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_data_a) $LIBRARIES(L1_data_a))
            INPUT_SECTIONS( $OBJECTS(cplb_data) $LIBRARIES(cplb_data))
            INPUT_SECTIONS($OBJECTS(data1) $LIBRARIES(data1))
            INPUT_SECTIONS($OBJECTS(constdata) $LIBRARIES(constdata))
	    INPUT_SECTIONS($OBJECTS(voldata) $LIBRARIES(voldata))
#endif /* USE_CACHE } */
        } >MEM_L1_DATA_A_CACHE

        l1_data_b
        {
#ifdef USE_CACHE /* { */
		___l1_data_cache_b = 1;
#else
		___l1_data_cache_b = 0;
	    INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(L1_data_b) $LIBRARIES(L1_data_b))
            INPUT_SECTIONS( $OBJECTS(cplb_data) $LIBRARIES(cplb_data))
            INPUT_SECTIONS($OBJECTS(constdata) $LIBRARIES(constdata))
	    INPUT_SECTIONS($OBJECTS(voldata) $LIBRARIES(voldata))
            INPUT_SECTIONS($OBJECTS(data1) $LIBRARIES(data1))
#endif /* USE_CACHE } */
        } >MEM_L1_DATA_B_CACHE



#ifdef USE_CACHE /* { */
        bsz ZERO_INIT
        {
        	INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(bsz) $LIBRARIES(bsz))
        } >MEM_SDRAM0

#else
        bsz ZERO_INIT
        {
        	INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(bsz) $LIBRARIES(bsz))
        } >MEM_L1_DATA_A

#endif /* USE_CACHE } */

        bsz_init
        {
        	INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(bsz_init) $LIBRARIES(bsz_init))
        } >MEM_L1_DATA_B
        .meminit {} >MEM_L1_DATA_B

        stack
        {
            ldf_stack_space = .;
            ldf_stack_end = ldf_stack_space + MEMORY_SIZEOF(MEM_L1_DATA_B_STACK);
        } >MEM_L1_DATA_B_STACK

#ifdef USE_CACHE /* { */
        heap
        {
            // Allocate a heap for the application
            ldf_heap_space = .;
            ldf_heap_end = ldf_heap_space + MEMORY_SIZEOF(MEM_SDRAM0_HEAP) - 1;
            ldf_heap_length = ldf_heap_end - ldf_heap_space;        
        } >MEM_SDRAM0_HEAP
#else
        heap
        {
            // Allocate a heap for the application
            ldf_heap_space = .;
            ldf_heap_end = ldf_heap_space + MEMORY_SIZEOF(MEM_L1_DATA_A_CACHE) - 1;
            ldf_heap_length = ldf_heap_end - ldf_heap_space;        
        } >MEM_L1_DATA_A_CACHE
#endif /* USE_CACHE } */

        sdram
        {
#ifdef USE_CACHE /* { */
	    INPUT_SECTION_ALIGN(4)
            INPUT_SECTIONS( $OBJECTS(sdram0) $LIBRARIES(sdram0))
            INPUT_SECTIONS( $OBJECTS(program) $LIBRARIES(program))
            INPUT_SECTIONS( $OBJECTS(cplb) $LIBRARIES(cplb))
            INPUT_SECTIONS( $OBJECTS(cplb_code) $LIBRARIES(cplb_code))
            INPUT_SECTIONS($OBJECTS(data1) $LIBRARIES(data1))
	    INPUT_SECTIONS($OBJECTS(voldata) $LIBRARIES(voldata))
            INPUT_SECTIONS($OBJECTS(constdata) $LIBRARIES(constdata))
            INPUT_SECTIONS( $OBJECTS(cplb_data) $LIBRARIES(cplb_data))
#endif /* USE_CACHE } */
        } >MEM_SDRAM0

    }
}
